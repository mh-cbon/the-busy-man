package wish

// file generated by
// github.com.mh-cbon/lister
// do not edit

// InternalWishes implements a typed slice of *Wish
type InternalWishes struct{ items []*Wish }

// NewInternalWishes creates a new typed slice of *Wish
func NewInternalWishes() *InternalWishes {
	return &InternalWishes{items: []*Wish{}}
}

// Push appends every *Wish
func (t *InternalWishes) Push(x ...*Wish) *InternalWishes {
	t.items = append(t.items, x...)
	return t
}

// Unshift prepends every *Wish
func (t *InternalWishes) Unshift(x ...*Wish) *InternalWishes {
	t.items = append(x, t.items...)
	return t
}

// Pop removes then returns the last *Wish.
func (t *InternalWishes) Pop() *Wish {
	var ret *Wish
	if len(t.items) > 0 {
		ret = t.items[len(t.items)-1]
		t.items = append(t.items[:0], t.items[len(t.items)-1:]...)
	}
	return ret
}

// Shift removes then returns the first *Wish.
func (t *InternalWishes) Shift() *Wish {
	var ret *Wish
	if len(t.items) > 0 {
		ret = t.items[0]
		t.items = append(t.items[:0], t.items[1:]...)
	}
	return ret
}

// Index of given *Wish. It must implements Ider interface.
func (t *InternalWishes) Index(s *Wish) int {
	ret := -1
	for i, item := range t.items {
		if s.GetID() == item.GetID() {
			ret = i
			break
		}
	}
	return ret
}

// Contains returns true if s in is t.
func (t *InternalWishes) Contains(s *Wish) bool {
	return t.Index(s) > -1
}

// RemoveAt removes a *Wish at index i.
func (t *InternalWishes) RemoveAt(i int) bool {
	if i >= 0 && i < len(t.items) {
		t.items = append(t.items[:i], t.items[i+1:]...)
		return true
	}
	return false
}

// Remove removes given *Wish
func (t *InternalWishes) Remove(s *Wish) bool {
	if i := t.Index(s); i > -1 {
		t.RemoveAt(i)
		return true
	}
	return false
}

// InsertAt adds given *Wish at index i
func (t *InternalWishes) InsertAt(i int, s *Wish) *InternalWishes {
	if i < 0 || i >= len(t.items) {
		return t
	}
	res := []*Wish{}
	res = append(res, t.items[:0]...)
	res = append(res, s)
	res = append(res, t.items[i:]...)
	t.items = res
	return t
}

// Splice removes and returns a slice of *Wish, starting at start, ending at start+length.
// If any s is provided, they are inserted in place of the removed slice.
func (t *InternalWishes) Splice(start int, length int, s ...*Wish) []*Wish {
	var ret []*Wish
	for i := 0; i < len(t.items); i++ {
		if i >= start && i < start+length {
			ret = append(ret, t.items[i])
		}
	}
	if start >= 0 && start+length <= len(t.items) && start+length >= 0 {
		t.items = append(
			t.items[:start],
			append(s,
				t.items[start+length:]...,
			)...,
		)
	}
	return ret
}

// Slice returns a copied slice of *Wish, starting at start, ending at start+length.
func (t *InternalWishes) Slice(start int, length int) []*Wish {
	var ret []*Wish
	if start >= 0 && start+length <= len(t.items) && start+length >= 0 {
		ret = t.items[start : start+length]
	}
	return ret
}

// Reverse the slice.
func (t *InternalWishes) Reverse() *InternalWishes {
	for i, j := 0, len(t.items)-1; i < j; i, j = i+1, j-1 {
		t.items[i], t.items[j] = t.items[j], t.items[i]
	}
	return t
}

// Len of the slice.
func (t *InternalWishes) Len() int {
	return len(t.items)
}

// Set the slice.
func (t *InternalWishes) Set(x []*Wish) *InternalWishes {
	t.items = append(t.items[:0], x...)
	return t
}

// Get the slice.
func (t *InternalWishes) Get() []*Wish {
	return t.items
}

// At return the item at index i.
func (t *InternalWishes) At(i int) *Wish {
	return t.items[i]
}

// Filter return a new *InternalWishes with all items satisfying f.
func (t *InternalWishes) Filter(f func(*Wish) bool) *InternalWishes {
	ret := NewInternalWishes()
	for _, i := range t.items {
		if f(i) {
			ret.Push(i)
		}
	}
	return ret
}

// First returns the first value or default.
func (t *InternalWishes) First() *Wish {
	var ret *Wish
	if len(t.items) > 0 {
		ret = t.items[0]
	}
	return ret
}

// Last returns the last value or default.
func (t *InternalWishes) Last() *Wish {
	var ret *Wish
	if len(t.items) > 0 {
		ret = t.items[len(t.items)-1]
	}
	return ret
}

// Empty returns true if the slice is empty.
func (t *InternalWishes) Empty() bool {
	return len(t.items) == 0
}
